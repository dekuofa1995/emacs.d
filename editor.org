#+title: Editor Basics

Configuration for editor basics.

#+begin_src emacs-lisp
  ;;; -*- lexical-binding: t -*-
  (require 'cl-lib)
#+end_src

* Package Management

** straight

Straight.el is used for package management.
Bind some keys for quick operations.

#+begin_src emacs-lisp
  (setq straight-disable-native-compile t)
  (setq straight-disable-compile t)
  (defvar straight-keymap
    (let ((keymap (make-keymap)))
      (define-key keymap "c" 'straight-check-package)
      (define-key keymap "C" 'straight-check-all)
      (define-key keymap "p" 'straight-pull-package)
      (define-key keymap "P" 'straight-pull-all)
      (define-key keymap "b" 'straight-rebuild-package)
      (define-key keymap "B" 'straight-rebuild-all)
      keymap))

  (defalias 'straight-keymap straight-keymap)
  (global-set-key (kbd "C-c P") 'straight-keymap)
#+end_src

* Dired
#+begin_src emacs-lisp
  ;; dired configurations
  (use-package dired
    :ensure nil
    :bind
    (:map dired-mode-map
          ("e" . dired-previous-line)
          ("v" . meow-visit)
          ("C-c C-w" . wdired-change-to-wdired-mode)
          ("C-c C-n" . dired-create-empty-file))
    :config
    ;; Guess a default taregt directory
    (setq dired-dwim-target t)
    ;; keep one dired buffer when change directory in dired
    (setq dired-kill-when-opening-new-dired-buffer t)
    ;; Always delete and copy recursively
    (setq dired-recursive-copies 'always
          dired-recursive-deletes 'always)

    ;; show the size of file by k/M/G & dirs first
    (setq dired--listing-switches "-alh --group-directories-first")

    (when sys/macp
      (if (executable-find "gls")
          (progn
            ;; Use GNU ls as `gls' from `coreutils' if available
            (setq insert-directory-program "gls")
            (setq ls-lisp-use-insert-directory-program t))
        (progn
          ;; Suppress the warning: `ls does not support --dired'.
          (setq dired-use-ls-dired nil)
          (setq dired-listing-switches "-alh"))))
    )
#+end_src

** COMMENT Dired Quick Sort
#+begin_src emacs-lisp
  (use-package dired-quick-sort
    :bind (:map dired-mode-map
                ("S" . hydra-dired-quick-sort/body)))
#+end_src

** Dired Git Info
#+begin_src emacs-lisp
  (use-package dired-git-info
    :bind (:map dired-mode-map
                (")" . dired-git-info-mode)))
#+end_src
** Diredfl
Make dired more colorful.
#+begin_src emacs-lisp
  (use-package diredfl
    :hook (dired-mode . diredfl-mode))
#+end_src

** Extra Dired functionalities
#+begin_src emacs-lisp
  (use-package dired-aux
    :after dired
    :ensure nil)

  (use-package dired-x
    :ensure nil
    ;;:straight (:type built-in)
    :after (dired)
    :config
    (let ((cmd (cond (sys/mac-x-p "open")
                     (sys/linux-x-p "xdg-open")
                     (sys/win32p "start")
                     (t ""))))
      (setq dired-guess-shell-alist-user
            `(("\\.pdf\\'" ,cmd)
              ("\\.docx\\'" ,cmd)
              ("\\.\\(?:djvu\\|eps\\)\\'" ,cmd)
              ("\\.\\(?:jpg\\|jpeg\\|png\\|gif\\|xpm\\)\\'" ,cmd)
              ("\\.\\(?:xcf\\)\\'" ,cmd)
              ("\\.csv\\'" ,cmd)
              ("\\.tex\\'" ,cmd)
              ("\\.\\(?:mp4\\|mkv\\|avi\\|flv\\|rm\\|rmvb\\|ogv\\)\\(?:\\.part\\)?\\'" ,cmd)
              ("\\.\\(?:mp3\\|flac\\)\\'" ,cmd)
              ("\\.html?\\'" ,cmd)
              ("\\.md\\'" ,cmd))))
    (setq dired-omit-files
          (concat dired-omit-files
                  "\\|^.DS_Store$\\|^.projectile$\\|^.git*\\|^.svn$\\|^.vscode$\\|\\.js\\.meta$\\|\\.meta$\\|\\.elc$\\|^.emacs.*\\|~$"))
    )

#+end_src
** COMMENT Omit Dot Files
- ignore =dot= files in dired
#+begin_src emacs-lisp
  (defun enable-dired-omit-mode () (dired-omit-mode 1))
  (add-hook 'dired-mode-hook 'enable-dired-omit-mode)

  (defun recover-session@before (&rest _)
    "disable dired omit for recover-session"
    (let ((dired-mode-hook dired-mode-hook))
      (remove-hook 'dired-mode-hook 'enable-dired-omit-mode)))

  (advice-add 'recover-session :before #'recover-session@before)

  (defun dired-dotfiles-toggle ()
    "Show/hide dot-files"
    (interactive)
    (when (equal major-mode 'dired)
      (if (or (not (boundp 'dired-dotfiles-show-p)) dired-dotfiles-show-p) ; if currently showing
          (progn
            (set (make-local-variable 'dired-dotfiles-show-p) nil)
            (dired-mark-ifles-regexp "^\\\.")
            (dired-do-kill-lines))
        (progn (revert-buffer)
               (set (make-local-variable 'dired-dotfiles-show-p) t)))))

#+end_src

* Better defaults

#+begin_src emacs-lisp

  (setq-default

   inhibit-startup-screen t
   ;; Don't display comp warnings
   warning-suppress-log-types '((comp))
   ;; Don't create lockfiles
   create-lockfiles nil

   ;; prefer UTF8
   buffer-file-coding-system 'utf-8-unix
   default-file-name-coding-system 'utf-8-unix
   default-keyboard-coding-system 'utf-8-unix
   default-process-coding-system '(utf-8-unix . utf-8-unix)
   default-sendmail-coding-system 'utf-8-unix
   default-terminal-coding-system 'utf-8-unix

   ;; Add newline at bottom of file
   require-final-newline t

   ;; Backup setups
   ;; We use temporary directory /tmp for backup files
   ;; More versions should be saved
   backup-directory-alist `((".*" . ,temporary-file-directory))
   auto-save-file-name-transforms `((".*" ,temporary-file-directory t))
   backup-by-copying t
   delete-old-versions t
   kept-new-versions 6
   kept-old-versions 2
   version-control t

   ;; Skip prompt for xref find definition
   xref-prompt-for-identifier nil

   ;; Don't wait for keystrokes display
   echo-keystrokes 0.01

   ;; Disable margin for overline and underline
   overline-margin 0
   underline-minimum-offset 0

   ;; Allow resizing frame by pixels
   frame-resize-pixelwise t

   ;; Better scroll behavior
   mouse-wheel-scroll-amount '(1 ((shift) . 1) ((control) . nil))
   mouse-wheel-progressive-speed nil

   ;; scroll margin
   scroll-margin 15
   scroll-step 1
   ;; Disable copy region blink
   copy-region-blink-delay 0

   ;; Use short answer when asking yes or no
   read-answer-short t

   ;; Always follow link
   vc-follow-symlinks t

   ;; Use custom.el as custom file
   custom-file (expand-file-name "custom.el" user-emacs-directory)

   ;; Disable ring bell
   ring-bell-function 'ignore

   ;; Mouse yank at current point
   mouse-yank-at-point t

   ;; DWIM target for dired
   ;; Automatically use another dired buffer as target for copy/rename
   dired-dwim-target t

   ;; Don't echo multiline eldoc
   eldoc-echo-area-use-multiline-p nil)

  ;; fix chinese input lag from https://emacs-china.org/t/linux/12971/22
  (set-language-environment 'utf-8)
  (load custom-file)

#+end_src


#+begin_src emacs-lisp
  ;; enable a pair of parenthes match mode
  (show-paren-mode t)

  (global-subword-mode 1)
  ;; (require 'subword-mode)
  (with-eval-after-load 'diminish
    (diminish 'subword-mode))

  (global-hl-line-mode t)
  (setq global-auto-revert-non-file-buffers t)
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
  ;; enable line numbers
  (defun my/enable-line-numbers ()
    (interactive)
    (display-line-numbers-mode 1))
  ;; (add-hook 'prog-mode-hook #'my/enable-line-numbers)
  ;; (add-hook 'prog-mode-hook #'my/enable-line-numbers)
  ;; (global-display-line-numbers-mode 1)

  (save-place-mode 1) ;; remember the last cursor location

#+end_src

** Auto focus to new split window
#+begin_src emacs-lisp
  (defun switch-to-new-window (&rest r) (other-window 1))
  (advice-add #'split-window-below :after #'switch-to-new-window)
  (advice-add #'split-window-right :after #'switch-to-new-window)
#+end_src
* Avy
#+begin_src emacs-lisp
  ;; send t as first arg make avy only jump words in current window
  (use-package avy
    :defer t
    :custom-face
    (avy-lead-face ((t (:foreground "#00dfff" :background nil :wegith 'bold))))
    (avy-lead-face-0 ((t (:foreground "#2b8db3" :background nil))))
    (avy-lead-face-1 ((t (:foreground "#2b8db3" :background nil))))
    (avy-lead-face-2 ((t (:foreground "#2b8db3" :background nil))))
    :custom
    ;; colemak layout keys
    (avy-keys '(?a ?r ?s ?t ?d ?h ?n ?e ?i ?o))
    :bind
    ("C-'" . avy-goto-symbol-1)
    ("C-\"" . avy-goto-char) ;; C-S-'
    )
#+end_src
* Meow

This configuration sticks with Meow for modal editing.

Key bindings are defined in [[file:private.org::#Modal Editing Key Binding][private]] config.

#+begin_src emacs-lisp
  (use-package meow
    ;; hide lighters
    :init
    ;; custom variables
    (setq meow-esc-delay 0.001)
    (setq meow-char-thing-table
          ;; ascii code - meow's thing
          '((?\(	.	round)   ;; (
            (?\)	.	round)   ;; )
            (?\"      .       string)  ;; "
            (?\[	.	square)  ;; [
            (?\]	.	square)  ;; ]
            (?<	.	angle)  ;; <
            (?>	.	angle)  ;; >
            (?{	.	curly)  ;; {
            (?}	.	curly)  ;; }
            (?s	.	symbol) ;; s
            (?f	.	defun)  ;; f
            (?w	.	window) ;; w
            (?l	.	line)   ;; l
            (?b	.	buffer)  ;; b
            (?p	.	paragraph))) ;; p

    :config
    (require 'meow)
    ;; (meow-define-state disable "dummy state")
    (add-to-list 'meow-mode-state-list '(dashboard-mode . motion))
    (add-to-list 'meow-mode-state-list '(calculator-mode . insert))
    (setq meow-cheatsheet-layout meow-cheatsheet-layout-colemak)
    ;; (meow-leader-define-key '("\\" . split-window-right)) ;; corresponding variable is 'mode-specific-map
    (meow-setup)
    ;; (meow-setup-indicator)
    (meow-thing-register 'angle
                         '(pair ("<") (">"))
                         '(pair ("<") (">")))
    (add-to-list 'meow-char-thing-table
                 '(?< . angle))
    (add-to-list 'meow-char-thing-table
                 '(?> . angle))
    (meow-setup-line-number)

    (add-to-list 'meow-mode-state-list
                 '(cargo-process-mode . motion))
    (custom-set-faces
     '(meow-insert-indicator ((t (:background "#acf2bd" :foreground "black")))))
    ;; (meow-normal-define-key '("/" . meow-visit))

    (unless (bound-and-true-p meow-global-mode)
      (meow-global-mode 1)))
  ;; (with-eval-after-load 'meow
  ;;   ;; when window-system
  ;;     (setq meow-replace-state-name-list
  ;; 	  (concat
  ;; 	   '((normal . "🅝")
  ;; 	    (beacon . "🅑")
  ;; 	    (insert . "🅘")
  ;; 	    (motion . "🅜")
  ;; 	    (keypad . "🅚"))
  ;; 	   meow-replace-state-name-list)))

  ;; (with-eval-after-load 'diminish
  ;;   (diminish 'meow-normal-mode)
  ;;   (diminish 'meow-motion-mode)
  ;;   (diminish 'meow-insert-mode)
  ;;   (diminish 'meow-keypad-mode)
  ;;   (diminish 'meow-beacon-mode))
#+end_src

* Window management

Switch window by pressing the number showned in the mode line.

#+begin_src emacs-lisp
  (use-package window-numbering
    ;;:straight (window-numbering
               ;; :repo "DogLooksGood/window-numbering.el"
               ;; :host github
               ;; :type git)
    :config
    (window-numbering-mode 1))

  (defun meomacs-window-numbering-modeline ()
    (concat " "
            (let ((n (window-numbering-get-number)))
              (if window-system
                  (alist-get
                   n
                   '((0 . "⓪")
                     (1 . "①")
                     (2 . "②")
                     (3 . "③")
                     (4 . "④")
                     (5 . "⑤")
                     (6 . "⑥")
                     (7 . "⑦")
                     (8 . "⑧")
                     (9 . "⑨")))
                (number-to-string n)))))

  (setq window-numbering-assign-func
        (lambda ()
          (when (string-prefix-p " *Treemacs"
                                 (buffer-name))
            9)))

  (let ((modeline-segment '(:eval (meomacs-window-numbering-modeline))))
    (unless (member modeline-segment mode-line-format)
      (setq-default mode-line-format (cons modeline-segment mode-line-format))))
#+end_src


** golden-ratio

#+begin_src emacs-lisp
  (use-package golden-ratio
    :defer t
    :bind
    (:map mode-specific-map
          ("\\" . #'golden-ratio)))
#+end_src


** ace-window
#+begin_src emacs-lisp
  (global-set-key (kbd "C-c j") 'select-frame-by-name)

  ;; Better to have title name with project name
  (setq-default frame-title-format
                '((:eval
                   (or (cdr (project-current))
                       (buffer-name)))))
#+end_src

** COMMENT Using tab-bar-mode

Use tabs for workspaces.

#+begin_src emacs-lisp
  ;; We could hide the window decoration
  ;; (setq default-frame-alist '((undecorated . t)))

  (add-hook 'after-init-hook
            (lambda ()
              (tab-rename "*Emacs*")))

  (defun meomacs-format-tab (tab i)
    (let ((current-p (eq (car tab) 'current-tab)))
      (concat
       (propertize (concat
                    " "
                    (alist-get 'name tab)
                    " ")
                   'face
                   (funcall tab-bar-tab-face-function tab))
       " ")))

  (setq tab-bar-border nil
        tab-bar-close-button nil
        tab-bar-new-button (propertize " 🞤 " 'display '(:height 2.0))
        tab-bar-back-button nil
        tab-bar-tab-name-format-function 'meomacs-format-tab
        tab-bar-tab-name-truncated-max 10)

  (tab-bar-mode 1)

  (global-set-key (kbd "C-c j") 'tab-bar-switch-to-tab)
  (global-set-key (kbd "C-<next>") 'tab-bar-switch-to-next-tab)
  (global-set-key (kbd "C-<prior>") 'tab-bar-switch-to-prev-tab)
  (global-set-key (kbd "C-<escape>") 'tab-bar-close-tab)
#+end_src

Add missing keybindings

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x t .") 'tab-bar-rename-tab)
#+end_src

** COMMENT Builtin electric pair

#+begin_src emacs-lisp
  (require 'pair)

  (add-hook 'prog-mode-hook 'electric-pair-local-mode)
  (add-hook 'conf-mode-hook 'electric-pair-local-mode)
  ;; disable <> auto pairing in electric-pair-mode for org-mode
  (add-hook 'org-mode-hook
            '(lambda ()
               (setq-local electric-pair-inhibit-predicate
                           `(lambda (c)
                              (if (char-equal c ?<) t
                                (,electric-pair-inhibit-predicate c))))))
#+end_src

** Smartparens

Use smartparens for auto pairs, toggle strict mode with =C-c t s=.

#+begin_src emacs-lisp
  (use-package smartparens
    ;; :hook ((prog-mode conf-mode org-mode) . smartparens-mode)
    :bind
    ("C-M-e" . sp-end-of-sexp)
    ("C-M-a" . sp-beginning-of-sexp)
    :init
    (setq sp-highlight-pair-overlay nil
          sp-highlight-wrap-overlay nil)

    :config
    (smartparens-global-mode t)
    ;; (smartparens-strict-mode t)
    ;; setup for emacs-lisp
    (sp-with-modes '(emacs-lisp-mode)
      (sp-local-pair "'" nil :actions nil))
    ;; add emphasis keybinding to C-= in org-mode
    ;; and let smartparens consider `=' as a kind of pair
    ;; see https://github.com/Fuco1/.emacs.d/blob/2c302dcbedf2722c5c412b6a6d3e3258f6ac1ccf/files/smartparens.el#L96
    ;; (sp-with-modes 'org-mode
    ;;   (sp-local-pair "=" "=" :wrap "C-=")
    ;;   (sp-local-pair "~" "~" :wrap "C-~")
    ;;   (sp-local-pair "/" "/")
    ;;   (sp-local-pair "_" "_" :wrap "C-_")
    ;;   )

    ;; ;; Use strict-mode by default
    ;; (add-hook 'smartparens-mode-hook 'smartparens-strict-mode)

    ;; Keybindings
    (define-key toggle-map "s" 'smartparens-strict-mode))
#+end_src
*** Custom pairs
[[https://ebzzry.com/en/emacs-pairs/][Emacs-pairs]]
#+begin_src emacs-lisp

  (defmacro def-pairs (pairs)
    "Define functions for pairing. PAIRS is an alist of (NAME . STRING)
  conses, where NAME is the function name that will be created and
  STRING is a single-character string that marks the opening character.

    (def-pairs ((paren . \"(\")
                (bracket . \"[\"))

  defines the functions WRAP-WITH-PAREN and WRAP-WITH-BRACKET,
  respectively."
    `(progn
       ,@(cl-loop for (key . val) in pairs
                  collect
                  `(defun ,(read (concat
                                  "wrap-with-"
                                  (prin1-to-string key)
                                  "s"))
                       (&optional arg)
                     (interactive "p")
                     (sp-wrap-with-pair ,val)))))

  (def-pairs ((paren . "(")
              (bracket . "[")
              (brace . "{")
              (single-quote . "'")
              (double-quote . "\"")
              (back-quote . "`")))

  (global-set-key (kbd "C-M-[") #'sp-unwrap-sexp)
  (global-set-key (kbd "C-M-]") #'sp-backward-unwrap-sexp)
  ;; wrap keybindings
  (global-set-key (kbd "C-c {") #'wrap-with-braces)
  (global-set-key (kbd "C-c (") #'wrap-with-parens)
  (global-set-key (kbd "C-c [") #'wrap-with-brackets)
  (global-set-key (kbd "C-c \"") #'wrap-with-double-quotes)
#+end_src
** rainbow-delimiters
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :defer t
    :hook ((prog-mode org-mode) . rainbow-delimiters-mode)
    :init
    (defun my-pick-face-func (depth match loc)
      "Only enable rainbow for parentheses"
      (when (memq (char-after loc) '(?\( ?\)))
        (rainbow-delimiters-default-pick-face depth match loc)))
    ;; (setq rainbow-delimiters-pick-face-function #'my-pick-face-func)
    ;; (setq rainbow-delimiters-mode 1)
    )

#+end_src

* Completion for key sequence

** Which-key
#+begin_src emacs-lisp
  (use-package which-key
    :defer t
    :diminish t
    :hook (after-init . which-key-mode))
#+end_src

* Minibuffer completion reading

** Consult
#+begin_src emacs-lisp
  (use-package consult
    :defer t
    :bind
    ( ;; C-c bindings (mode-specific-map)
     ("C-c M-x"			.	consult-mode-command)
     ("C-c c i"			.	consult-info)
     ("C-c m"			.	consult-man)
     ("C-c h"			.	consult-history)
     ([remap Info-search]		.	consult-info)
     ("M-s e"			.	consult-isearch-history)
     ([remap switch-to-buffer]	.	consult-buffer)
     ;; C-x bindings (ctrl-x-map)
     ("C-x M-:"	.	consult-complex-command)
     ;; ("C-x b"	.	consult-buffer)
     ("C-x r b"	.	consult-bookmark)              ;; orig. bookmark-jump
     ("C-x p b"	.	consult-project-buffer)
     ;; Custom M-# bindings for fast register access
     ("M-#"	.	consult-register-load)
     ;; orig. abbrev-prefix-mark (unrelated)
     ("M-'"	.	consult-register-store)
     ("C-M-#"	.	consult-register)
     ;; Other custom bindings
     ("M-y"	.	consult-yank-pop)
     ;; M-g bindings (goto-map)
     ("M-g e"	.	consult-compile-error)
     ("M-g g"	.	consult-goto-line)
     ("M-g M-g"	.	consult-goto-line)
     ("M-g o"	.	consult-outline)
     ("M-g m"	.	consult-mark)
     ("M-g k"	.	consult-global-mark)
     ("M-g i"	.	consult-imenu)
     ("M-g I"	.	consult-imenu-multi)
     ("M-g b"	.	consult-project-buffer)
     ;; M-s bindings (search-map)
     ("M-s f"	.	consult-find)
     ;; ("M-s D"	.	consult-locate)
     ("M-s g"	.	consult-grep)
     ("M-s G"	.	consult-git-grep)
     ("M-s r"	.	consult-ripgrep)
     ("M-s l"	.	consult-line)
     ("M-s L"	.	consult-line-multi)
     ("M-s r"	.	xref-find-references)

     ("M-s k"	.	consult-keep-lines)
     ("M-s u"	.	consult-focus-lines)
     ;; Isearch integration
     ("M-s e"	.	consult-isearch-history)
     :map isearch-mode-map
     ("M-e"       .	consult-isearch-history)
     ("M-s e"	.	consult-isearch-history)
     ("M-s l"	.	consult-line)

     ("M-s L"	.	consult-line-multi)
     :map minibuffer-local-map
     ("M-s"	.	consult-history)
     ("M-r"	.	consult-history))
    ;; Enable automatic preview at point in the *Completions* buffer. This is
    ;; relevant when you use the default completion UI.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    :init
    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.5
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)
    (defvar my/consult-load-path "straight/build/consult/")
    :config
    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     ;; :preview-key "M-."
     :preview-key '(:debounce 0.4 any))
    )
#+end_src
*** consult-eglot
#+begin_src emacs-lisp
  (use-package consult-eglot
    :after (consult eglot)
    :bind
    ("M-s d" . consult-eglot-symbols))
#+end_src
*** consult-flycheck
#+begin_src emacs-lisp
  (use-package consult-flycheck
    :after consult
    :bind
    (:map flycheck-mode-map
          ("M-g f" . consult-flycheck)))
#+end_src
** Vertico

- Vertico provides a better UX for completion reading.

#+begin_src emacs-lisp
  (use-package vertico
    :defer t
    :hook (dashboard-mode . vertico-mode)
    :bind
    (:map vertico-map
          ("C-<return>" . vertico-exit-input))
    :config
    (vertico-mode 1)
    (setq completion-in-region-function
          (lambda (&rest args)
            (apply (if vertico-mode
                       #'consult-completion-in-region
                     #'completion--in-region)
                   args)))
    )

  (defvar my/vertico-load-path "straight/build/vertico/extensions/")
#+end_src
*** COMMENT vertico-directory

#+begin_src emacs-lisp
  (use-package vertico-directory
    :defer t
    :after vertico
    ;;:straight nil
    :load-path my/vertico-load-path
    :hook
    ;; tidi shadowed file names
    (rfn-eshadow-update-overlay . vertical-directory-tidy)
    :bind (:map vertico-map
                ("DEL" . #'vertico-directory-delete-char)
                ("M-DEL" . #'vertico-directory-delete-word)))
#+end_src


*** vertico-multiform
#+begin_src emacs-lisp
  (use-package vertico-multiform
    :defer t
    :hook (vertico-mode . vertico-multiform-mode)
    :load-path my/vertico-load-path
    :init
    (setq vertico-multiform-commands
          '((consult-line
             posframe
             (vertico-posframe-poshandler . posframe-poshandler-frame-top-center)
             (vertico-posframe-border-width . 10)
             ;; NOTE: This is useful when emacs is used in both in X and
             ;; terminal, for posframe do not work well in terminal, so
             ;; vertico-buffer-mode will be used as fallback at the
             ;; moment.
             (vertico-posframe-fallback-mode . vertico-buffer-mode))
            `(consult-imenu buffer indexed)
            `(consult-outline buffer ,(lambda (_) (text-scale-set -1)))
            (t posframe)))

    ;; Configure the display per completion category.
    ;; Use the grid display for files and a buffer
    ;; for the consult-grep commands.
    (setq vertico-multiform-categories
          '((file grid)
            (consult-grep buffer))))
#+end_src
*** COMMENT Emacs
#+begin_src emacs-lisp
  ;; A few more useful configurations...
  (use-package emacs
    :init
    ;; Add prompt indicator to `completing-read-multiple'.
    ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
    (defun crm-indicator (args)
      (cons (format "[CRM%s] %s"
                    (replace-regexp-in-string
                     "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                     crm-separator)
                    (car args))
            (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
          '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

    ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
    ;; Vertico commands are hidden in normal buffers.
    ;; (setq read-extended-command-predicate
    ;;       #'command-completion-default-include-p)

    ;; Enable recursive minibuffers
    (setq enable-recursive-minibuffers t))
#+end_src
*** Prescient

#+begin_src emacs-lisp
  (use-package prescient
    :defer t
    :hook (vertico-mode . prescient-persist-mode))

  (use-package vertico-prescient
    :defer t
    :hook (vertico-mode . vertico-prescient-mode))
#+end_src
** Fix M-DEL in minibuffer

Do "delete" instead of "kill" when pressing =M-DEL=.

#+begin_src emacs-lisp
  (defun meomacs-backward-delete-sexp ()
    "Backward delete sexp.

  Used in minibuffer, replace the the default kill behavior with M-DEL."
    (interactive)
    (save-restriction
      (narrow-to-region (minibuffer-prompt-end) (point-max))
      (delete-region
       (save-mark-and-excursion
         (backward-sexp)
         (point))
       (point))))

  (define-key minibuffer-local-map (kbd "M-DEL") #'meomacs-backward-delete-sexp)
#+end_src


** Margin Note for Minibuffer
#+begin_src emacs-lisp
  ;; Enable rich annotations using the Marginalia package
  (use-package marginalia
    ;; :defer t
    ;; Either bind `marginalia-cycle' globally or only in the minibuffer
    :bind (
           :map minibuffer-local-map
           ("M-A" . marginalia-cycle))

    ;; The :init configuration is always executed (Not lazy!)
    :init
    ;; Must be in the :init section of use-package such that the mode gets
    ;; enabled right away. Note that this forces loading the package.
    (marginalia-mode))
#+end_src

** Child frames and Popups
Use child frame replace ~minibuffer~.
#+begin_src emacs-lisp
  (use-package vertico-posframe
    :defer t
    :hook (vertico-mode . vertico-posframe-mode)
    :custom
    (vertico-posframe-parameters
          '((left-fringe . 8)
            (right-fringe . 8))))
#+end_src
* Search and Replace
** iedit
- =C-;=: ~iedit~
#+begin_src emacs-lisp
  (use-package iedit
    :defer t
    :bind
    ("C-;" . iedit-mode)
    ("C-M-;" . iedit-rectangle-mode))
#+end_src

* Embark
** COMMENT Enhance with smartparens
Must set the corresponding ~pair~ in =smartparens=
#+begin_src emacs-lisp
  (require 'smartparens)
  (defmacro my/sp-wrap-with-pair* (name pair)
    (macroexpand
     `(let ((fname (format "my/sp-wrap-%s" ,name))
            (pa ,pair))
        `(defun ,(intern fname) (&rest arg)
           (interactive "P")
           (sp-wrap-with-pair ,pa)))))

#+end_src

*** Org-mode
#+begin_src emacs-lisp
  (with-eval-after-load 'embark
    (defun my/org-sp-binding ()
      (let ((pair-list
             '(("verbatim"  . "=")
               ("bold"      . "*")
               ("underline" . "_")
               ("code"      . "~")
               ("italic"    . "/"))))
        (dolist (pair pair-list)
          (eval-expression (my/sp-wrap-with-pair* (car pair) (cdr pair)))))

      (let ((bindings '(
                        ("e" . my/sp-wrap-emphasis)
                        ("b" . my/sp-wrap-bold)
                        ("u" . my/sp-wrap-underline)
                        ("v" . my/sp-wrap-verbatim)
                        ("p" . my/sp-wrap-code) ;; p: can be considered as programming
                        ("i" . my/sp-wrap-italic))
                      ))
        (dolist (binding bindings)
          (define-key embark-identifier-map (kbd (car binding))
                      (cdr binding)))))
    ;; set bindings to embark
    (my/org-sp-binding))
#+end_src
** Embark Init
#+begin_src emacs-lisp
  (use-package embark
    :bind
    (
     ("C-." . embark-act)
     ("C-M-'" . embark-dwim)
     ("C-h B" . embark-bindings) ;; alternative for `describe-bindings'
     (:map embark-identifier-map
           ("e" . org-previous-item) ;; orig. p
           ("I" . embark-insert) ;; orig. i
           )
     )
    ;; :init
    ;; for integration with `which-key'
    ;; see https://github.com/oantolin/embark/wiki/Additional-Configuration#use-which-key-like-a-key-menu-prompt
    ;; (setq prefix-help-command #'embark-prefix-help-command)
    :config

    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none))))
    )
#+end_src

** with Consult
#+begin_src emacs-lisp
  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

** Integration with which-key
#+begin_src emacs-lisp
  (defun embark-which-key-indicator ()
    "An embark indicator that displays keymaps using which-key.
  The which-key help message will show the type and value of the
  current target followed by an ellipsis if there are further
  targets."
    (lambda (&optional keymap targets prefix)
      (if (null keymap)
          (which-key--hide-popup-ignore-command)
        (which-key--show-keymap
         (if (eq (plist-get (car targets) :type) 'embark-become)
             "Become"
           (format "Act on %s '%s'%s"
                   (plist-get (car targets) :type)
                   (embark--truncate-target (plist-get (car targets) :target))
                   (if (cdr targets) "…" "")))
         (if prefix
             (pcase (lookup-key keymap prefix 'accept-default)
               ((and (pred keymapp) km) km)
               (_ (key-binding prefix 'accept-default)))
           keymap)
         nil nil t (lambda (binding)
                     (not (string-suffix-p "-argument" (cdr binding))))))))

  (setq embark-indicators
        '(embark-which-key-indicator
          embark-highlight-indicator
          embark-isearch-highlight-indicator))

  (defun embark-hide-which-key-indicator (fn &rest args)
    "Hide the which-key indicator immediately when using the completing-read prompter."
    (which-key--hide-popup-ignore-command)
    (let ((embark-indicators
           (remq #'embark-which-key-indicator embark-indicators)))
      (apply fn args)))

  (advice-add #'embark-completing-read-prompter
              :around #'embark-hide-which-key-indicator)
#+end_src

** Show the current Embark target types in the modeline
#+begin_src emacs-lisp
  (with-eval-after-load 'embark
    (defvar embark--target-mode-timer nil)
    (defvar embark--target-mode-string "")

    (defun embark--target-mode-update ()
      (setq embark--target-mode-string
            (if-let (targets (embark--targets))
                (format "[%s%s] "
                        (propertize (symbol-name (plist-get (car targets) :type)) 'face 'bold)
                        (mapconcat (lambda (x) (format ", %s" (plist-get x :type)))
                                   (cdr targets)
                                   ""))
              "")))

    (define-minor-mode embark-target-mode
      "Shows the current targets in the modeline."
      :global t
      (setq mode-line-misc-info (assq-delete-all 'embark-target-mode mode-line-misc-info))
      (when embark--target-mode-timer
        (cancel-timer embark--target-mode-timer)
        (setq embark--target-mode-timer nil))
      (when embark-target-mode
        (push '(embark-target-mode (:eval embark--target-mode-string)) mode-line-misc-info)
        (setq embark--target-mode-timer
              (run-with-idle-timer 0.1 t #'embark--target-mode-update))))
    (embark-target-mode))

#+end_src
* Template
** tempel

#+begin_src emacs-lisp
  (use-package tempel
    :diminish t
    :custom
    (tempel-trigger-prefix "<")
    ;; :hook
    ;; Optionally make the Tempel templates available to Abbrev,
    ;; either locally or globally. `expand-abbrev' is bound to C-x '.
    ;; ((prog-mode) . tempel-abbrev-mode)
    :bind (
           ("M-/" . tempel-expand)
           ("M-*" . tempel-insert)
           :map tempel-map
           ("C-p" . tempel-previous)
           ("C-n" . tempel-next))
    :init
    (defun tempel-setup-capf ()
      ;; Add the Tempel Capf to `completion-at-point-functions'.
      ;; `tempel-expand' only triggers on exact matches. Alternatively use
      ;; `tempel-complete' if you want to see all matches, but then you
      ;; should also configure `tempel-trigger-prefix', such that Tempel
      ;; does not trigger too often when you don't expect it. NOTE: We add
      ;; `tempel-expand' *before* the main programming mode Capf, such
      ;; that it will be tried first.
      (setq-local completion-at-point-functions
                  (add-to-list 'completion-at-point-functions #'tempel-complete)))
    (add-hook 'prog-mode-hook #'tempel-setup-capf)
    (add-hook 'org-mode-hook #'tempel-setup-capf)
    )
#+end_src

* Project management

** Project.el
built-in Project.el configuration.
#+begin_src emacs-lisp
  (with-eval-after-load 'project
    (let ((dirs '("lib")))
      (defun append-ignore-project-dirs@ (fn &rest args)
        `(,@dirs ,@(apply fn args)))
      (advice-add 'project-ignores :around 'append-ignore-project-dirs@)))
#+end_src

** Treemacs

#+begin_src emacs-lisp
  (use-package treemacs
    :ensure nil
    :defer t
    :init
    (setq treemacs-is-never-other-window nil)
    (setq treemacs-default-visit-action 'treemacs-visit-node-close-treemacs)
    :config

    (treemacs-fringe-indicator-mode 'always)
    (when treemacs-python-executable
      (treemacs-git-commit-diff-mode t))
    :bind
    (:map global-map
          ("C-x t w"   . treemacs-select-window)
          ("C-x t t"   . treemacs)
          ("C-x t 1"   . treemacs-delete-other-windows)
          ("C-x t B"   . treemacs-bookmark)
          ;; ("C-x t d"   . treemacs-select-directory)
          ;; ("C-x t C-t" . treemacs-find-file)
          ("C-x t M-t" . treemacs-find-tag))
    (:map treemacs-mode-map
          ;; navigation (colemak mappings)
          ("n" . #'treemacs-next-line)
          ("e" . #'treemacs-previous-line)
          ("i" . #'rootdown)
          ("N" . #'treemacs-next-project)
          ("E" . #'treemacs-previous-project)
          ("s" . treemacs-select-directory)
          ("S" . treemacs-resort) ;; orig. treemacs-resort
          ;; collapse
          ("c a" . #'treemacs-collapse-all-projects)
          ("c p" . #'treemacs-collapse-project)
          ("c o" . #'treemacs-collapse-other-projects)
          ;; workspace
          ("w"   . nil) ;; orig. treemacs-set-width
          ("w s" . treemacs-switch-workspace)
          ("w n" . treemacs-next-workspace)
          ;; FIXME: not found the command
          ;; ("w p" . treemacs-previous-workspace)
          ("w r" . treemacs-rename-workspace)
          ("w e" . treemacs-edit-workspaces)))
#+end_src
*** Treemacs
#+begin_src emacs-lisp
  (use-package treemacs-nerd-icons
    :defer t
    :init
    (with-eval-after-load 'treemacs
      (require 'treemacs-nerd-icons)
      (treemacs-load-theme "nerd-icons")))
#+end_src

** Find file in project

#+begin_src emacs-lisp
  (use-package find-file-in-project
    :defer t
    :bind
    ("C-c C-f" . find-file-in-project)
    :config
    ;; custom exclude dirs
    (let ((emacs
           '("straight" "elpa" "eln-cache" "\.cache" "lib" "devdocs" "epkgs"
             "autosave-list" "tree-sitter" "transient" "url" "newsticker"))
          (emacs-custom '("dirvish" "racket-mode"))
          (build '("dist")))
      (dolist (dlist (list emacs emacs-custom build))
        (dolist (dir dlist)
          (add-to-list 'ffip-prune-patterns (format "*/%s" dir)))))
    )
#+end_src

** Rg

#+begin_src emacs-lisp
  ;; ripgrep in emacs
  (use-package deadgrep :defer t)

  (use-package rg :defer t)
  ;; :bind
  ;; ("C-c s" . #'rg-menu))
#+end_src

* Separetly edit
** TODO sepatedit.el
[[w3m:https://github.com/twlz0ne/separedit.el][separedit.el]]


* Mode Line
** doom-modeline
#+begin_src emacs-lisp
  (use-package doom-modeline
    :defer t
    :custom
    (doom-modeline-project-detection 'ffip)
    :init
    (setq doom-modeline-icon t
          doom-modeline-major-mode-color-icon t
          doom-modeline-buffer-state-icon t
          ;; doom-modeline-hud t
          doom-modeline-support-imenu t
          doom-modeline-modal t
          doom-modeline-lsp t
          doom-modeline-indent-info t
          doom-modeline-github t
          )
    :hook
    (after-init . doom-modeline-mode)
    :config
    (doom-modeline-mode 1)
    ;; unused modeline items:  indent-info
    (doom-modeline-def-modeline 'my-mode-line
      '(bar modals matches buffer-info remote-host buffer-position parrot selection-info)
      '(misc-info minor-modes objed-state gnus debug lsp minor-modes input-method buffer-encoding major-mode process vcs checker))

    ;; '(bar " " modals " " window-number matches buffer-info remote-host buffer-position parrot selection-info)
    ;; '(misc-info objed-state battery grip irc mu4e gnus
    ;; 		github debug lsp minor-modes input-method
    ;; 		word-count buffer-encoding major-mode process vcs checker time))

    (defun my/setup-custom-doom-modeline ()
      (doom-modeline-set-modeline 'my-mode-line 'default))

    ;; (add-hook 'doom-modeline-mode-hook 'my/setup-custom-doom-modeline)

    (setq
     find-file-visit-truename t
     doom-modeline-github t
     doom-modeline-enable-word-count t
     doom-modeline-height 1)

    (custom-set-faces
     '(mode-line ((t (:height 0.9))))
     '(mode-line-active ((t (:height 0.9))))
     '(mode-line-inactive ((t (:height 0.9))))))
#+end_src

* Jupyter
** emacs-jupyter
#+begin_src emacs-lisp
  (use-package jupyter :defer t)
#+end_src

** ipynb
#+begin_src emacs-lisp
  (use-package ein
    :defer t
    :commands (ein:run))
#+end_src

* Wgrep
#+begin_src emacs-lisp
  (use-package wgrep
    :defer t
    :bind
    (:map grep-mode-map
          ("C-c C-p" . wgrep-change-to-wgrep-mode)))
#+end_src

* Popper.el
Keep the flood of ephemeral windows within arm's reach.

#+begin_src emacs-lisp
  (use-package popper
    :ensure nil
    :defer t
    :defines popper-echo-dispatch-actions
    :autoload popper-group-by-directory
    :custom
    (popper-echo-dispatch-actions t)
    :bind
    (:map popper-mode-map
          ;; ("C-`" . popper-toggle-latest)
          ;; ("M-`" . popper-cycle)
          ;; ("C-M-`" . popper-toggle-type)
          ("C-h z" . popper-toggle-latest)
          ("C-<tab>" . popper-cycle)
          ("C-M-<tab>" . popper-toggle-type))
    :hook (emacs-startup . popper-mode)
    :init
    (setq popper-group-function #'popper-group-by-directory)
    (setq popper-reference-buffers
          '("\\*Messages\\*"
            "Output\\*$"
            "\\*Async Shell Command\\*"
            "\\*Warnings\\*"
            "\\*Embark Actions\\*"
            "\\*Calendar\\*"
            "\\*Finder\\*"
            "\\*King Ring\\*"
            "\\*Apropos\\*"
            "\\*Pp Eval Output\\*$"

            compilation-mode
            bookmark-bmenu-mode
            comint-mode
            help-mode helpful-mode
            tabulated-list-mode
            Buffer-menu-mode

            flycheck-error-list-mode flycheck-verify-mode

            gnus-article-mode devdocs-mode
            grep-mode rg-mode deadgrep-mode ;; ag-mode pt-mode occur-mode

            "^\\*Process List\\*" process-menu-mode
            cargo-process-mode

            ;; "^\\*eshell.*\\*.*$"       eshell-mode
            ;; "^\\*shell.*\\*.*$"        shell-mode
            ;; "^\\*terminal.*\\*.*$"     term-mode
            "^\\*vterm[inal]*.*\\*.*$" vterm-mode

            "\\*DAP Templates\\*$" dap-server-log-mode
            "\\*ELP Profiling Restuls\\*" profiler-report-mode
            "\\*Paradox Report\\*$" "\\*package update results\\*$" "\\*Package-Lint\\*$"
            "\\*[Wo]*Man.*\\*$"
            "\\*ert\\*$" overseer-buffer-mode
            "\\*gud-debug\\*$"
            "\\*lsp-help\\*$" "\\*lsp session\\*$"
            "\\*quickrun\\*$"
            "\\*tldr\\*$"
            "\\*vc-.*\\*$"
            "^\\*macro expansion\\**"

            "\\*Agenda Commands\\*" "\\*Org Select\\*" "\\*Capture\\*" "^CAPTURE-.*\\.org*"
            "\\*Org Src\\*"
            ;; "\\*Gofmt Errors\\*$" "\\*Go Test\\*$" godoc-mode
            "\\*docker-.+\\*"
            "\\*prolog\\*" inferior-python-mode inf-ruby-mode swift-repl-mode
            "\\*rustfmt\\*$" rustic-compilation-mode rustic-cargo-clippy-mode
            ;; rustic-cargo-outdated-mode rustic-cargo-run-mode rustic-cargo-test-mode
            ))

    (with-eval-after-load 'doom-modeline
      (setq popper-mode-line
            '(:eval (let ((face (if (doom-modeline--active)
                                    'mode-line-emphasis
                                  'mode-line-inactive)))
                      (if (and (icons-displayable-p)
                               (bound-and-true-p doom-modeline-mode))
                          (format " %s "
                                  (nerd-icons-octicon "nf-oct-pin" :face face))
                        (propertize " POP" 'face face))))))
    :config
    (popper-echo-mode t)
    (with-no-warnings
      (defun my-popper-fit-window-height (win)
        "Determine the height of popup window WIN by fitting it to the buffer's content."
        (fit-window-to-buffer
         win
         (floor (frame-height) 3.3)
         (floor (frame-height) 3.3)))
      (setq popper-window-height #'my-popper-fit-window-height)

      (defun popper-close-window-hack (&rest _)
        "Close popper window via `C-g'."
        ;; `C-g' can deactivate region
        (when (and (called-interactively-p 'interactive)
                   (not (region-active-p))
                   popper-open-popup-alist)
          (let ((window (caar popper-open-popup-alist)))
            (when (window-live-p window)
              (delete-window window)))))
      (advice-add #'keyboard-quit :before #'popper-close-window-hack))
    )
#+end_src

* Comboblulate
Structure editing and movement for programming language.
#+begin_src emacs-lisp
  (use-package combobulate
    :ensure nil
    :defer t
    :hook ((python-ts-mode . combobulate-mode)
           (js-ts-mode . combobulate-mode)
           (css-ts-mode . combobulate-mode)
           (yaml-ts-mode . combobulate-mode)
           (typescript-ts-mode . combobulate-mode)
           (tsx-ts-mode . combobulate-mode)))
#+end_src

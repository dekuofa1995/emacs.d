#+title: Programming

Configuration for programming and languages support.

#+begin_src emacs-lisp
  ;;; -*- lexical-binding: t -*-
  (require 'cl-lib)
  (require 'init-funcs)
#+end_src

* Stick scroll

** Topsy for prog-mode
#+begin_src emacs-lisp
  (use-package topsy
    :defer t
    :bind
    (:map toggle-map
          ("s" . topsy-mode))
    :hook ((prog-mode). topsy-mode))
#+end_src

** org-sticky-header for org-mode

#+begin_src emacs-lisp
  (use-package org-sticky-header
    :defer t
    :hook
    (org-mode . org-sticky-header-mode))
#+end_src
* Force save file
#+begin_src emacs-lisp
  (defun save-buffer-always ()
    "Save the buffer even if it is not modified."
    (interactive)
    (set-buffer-modified-p t)
    (save-buffer))

  (global-set-key (kbd "<f5>") 'save-buffer-always)
#+end_src


* Flycheck

- cann't use =flycheck-pos-tip= for ~emacs-plus~ on MacOS, cause it missing the X Resources, so cann't adjust the font size in toop-tip

#+begin_src emacs-lisp
  (use-package flycheck
    :defer t
    :custom
    (flycheck-idle-change-delay 1.0)
    (flycheck-buffer-switch-check-intermediate-buffers t)
    (flycheck-display-errors-delay 0.25)
    (flycheck-display-errors-function #'flycheck-display-error-messages-unless-error-list)
    (flycheck-check-syntax-automatically '(save idle-change mode-enable))
    :hook ((prog-mode org-mode) . flycheck-mode))

  (use-package flycheck-popup-tip
    :defer t
    :hook (flycheck-mode . flycheck-popup-tip-mode))
#+end_src
** COMMENT Flycheck-rust
#+begin_src emacs-lisp
  (use-package flycheck-rust
    :init
    (with-eval-after-load 'rust-mode
      (add-hook 'flycheck-mode-hook #'flycheck-rust-setup)))
#+end_src
* Format
** Apheleia
#+begin_src emacs-lisp
  (use-package apheleia
    :ensure nil
    :defer t
    :bind ("C-c f" . apheleia-format-buffer)
    ;; :hook (prog-mode . apheleia-mode)
    :config
    (setf (alist-get 'python-ts-mode apheleia-mode-alist)
          '(isort black)))

#+end_src
** COMMENT Format All
#+begin_src emacs-lisp
  (use-package format-all
    :config
    (format-all-mode 1))
#+end_src

* Outline
#+begin_src emacs-lisp
  (use-package imenu-list
    :defer t
    :bind
    (:map imenu-list-major-mode-map
          ("e" . #'previous-line))
    (:map toggle-map
          ("i" . imenu-list)))
#+end_src

* Tree Sitter

Built-in since emacs29
** Treesit
#+begin_src emacs-lisp
  (use-package treesit
    :ensure nil
    :defer t
    :preface
    (defun mp-setup-install-grammars ()
      "Install Tree-sitter grammars if they are absent."
      (interactive)
      (dolist (grammar
               '((css "https://github.com/tree-sitter/tree-sitter-css")
                 (javascript . ("https://github.com/tree-sitter/tree-sitter-javascript" "master" "src"))
                 (python "https://github.com/tree-sitter/tree-sitter-python")
                 (tsx . ("https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src"))
                 (yaml "https://github.com/ikatyang/tree-sitter-yaml")))
        (add-to-list 'treesit-language-source-alist grammar)
        ;; Only install `grammar' if we don't already have it
        ;; installed. However, if you want to *update* a grammar then
        ;; this obviously prevents that from happening.
        (unless (treesit-language-available-p (car grammar))
          (treesit-install-language-grammar (car grammar)))))
    :init
    (add-hook 'prog-mode-hook (lambda () (require 'treesit)))
    :config
    (mp-setup-install-grammars))
#+end_src

** tree-sitter-auto
Enable tree-sitter for supported languages
#+begin_src emacs-lisp
  (use-package treesit-auto
    :hook (prog-mode . treesit-auto-mode)
    :config
    (setq treesit-auto-install 'prompt)
    (add-to-list 'major-mode-remap-alist '(python-mode . python-ts-mode))
    (add-to-list 'major-mode-remap-alist '(c-mode . c-ts-mode))
    (add-to-list 'major-mode-remap-alist '(c++-mode . c++-ts-mode))
    (add-to-list 'major-mode-remap-alist '(rust-mode . rust-ts-mode))
    (add-to-list 'major-mode-remap-alist
                 '(c-or-c++-mode . c-or-c++-ts-mode))
    (add-to-list 'auto-mode-alist
                 '("\\.ya?ml\\'" . yaml-ts-mode))

    (defun compile-and-run()
      (interactive)
      (let* ((src (file-name-nondirectory (buffer-file-name)))
             (exe (file-name-sans-extension src)))
        (compile (concat "clang " src " -o " exe) t)))
    (with-eval-after-load 'c-ts-mode
      (add-hook 'c-ts-mode-hook (lambda () (define-key c-ts-mode-map (kbd "C-c C-r") #'compile-and-run)))))
#+end_src


* LSP
Language Server Protocol

** Eglot

Built-in since emacs29

#+begin_src emacs-lisp
  ;; (add-hook 'prog-mode-hook (lambda () (require 'eglot)))
  (add-hook 'prog-mode-hook #'eglot-ensure)
  (with-eval-after-load 'eglot
    (with-eval-after-load 'flycheck-mode
      (defun +lsp-eglot-prefer-flycheck-h ()
        (when eglot--managed-mode)
        (flycheck-mode -1)
        (when-let ((current-checker (flycheck-get-checker-for-buffer)))
          ;; 关闭不需要的检查器
          (when (memq current-checker (list 'c/c++-clang 'rust-cargo 'python-pycompile))
            (flycheck-disable-checker current-checker))
          (unless (equal current-checker 'eglot)
            (flycheck-add-next-checker 'eglot current-checker))
          (flycheck-add-mode 'eglot major-mode)
          (flycheck-mode 1)
          (flycheck-buffer-deferred)))
      (add-hook 'eglot-managed-mode-hook #'+lsp-eglot-prefer-flycheck-h))

    (setq completion-category-defaults nil)
    (setq eglot-ignored-server-capabilites '(:documentHighlightProvider)
          read-process-output-max (* 1024 1024))
    (add-to-list 'eglot-server-programs
                 `((python-mode python-ts-mode) . ("pyright-langserver" "--stdio")))
    ;; (define-key eglot-mode-map (kbd "C-M-i") #'eglot-completion-at-point)
    (define-key eglot-mode-map (kbd "C-M-r")      #'eglot-rename)
    (define-key eglot-mode-map (kbd "<C-return>") #'eglot-code-actions)
    (define-key eglot-mode-map (kbd "C-M-f")      #'eglot-code-action-quickfix)
    (define-key eglot-mode-map (kbd "C-c C-l")    #'eglot-code-action-line)
    (define-key eglot-mode-map (kbd "C-c C-e")    #'eglot-code-action-extract)
    (define-key eglot-mode-map (kbd "C-c C-f")    #'eglot-format)
    (define-key eglot-mode-map (kbd "C-c C-o")    #'eglot-code-action-organize-imports)
    (define-key eglot-mode-map (kbd "C-c C-h")    #'eldoc))
#+end_src


** Languages' Configuration

*** COMMENT Swift
#+begin_src emacs-lisp
  (use-package swift-mode
    :init
    (add-to-list 'auto-mode-alist '("\\.swift$'" . swift-mode)))
#+end_src

*** COMMENT Rust
#+begin_src emacs-lisp
  (use-package rust-mode
    :init
    (add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-mode)))
#+end_src

* Dev Docs

#+begin_src emacs-lisp
  (use-package eldoc
    :defer t
    :diminish  eldoc-mode
    :hook ((prog-mode org-mode) . eldoc-mode))
  (use-package eshell
    :defer t)
  (use-package devdocs
    :defer t
    :init
    (setq eldoc-idle-delay 2)
    :hook
    ('python-mode-hook . (lambda () (setq-local devdocs-current-docs '("python~3.11")))))
#+end_src
* Debug

** COMMENT dap-mode
=dap-mode= will use =lsp-mode=, which I don't want use right now.
#+begin_src emacs-lisp
  (use-package dap-mode)
#+end_src

** Realgud
- =trepan3k= for ~python3~, can run ~trepan3k~ or ~realgud:trepan3k~
- =gdb= for multiple support languages, run ~realgud:gdb~, ~gdb~ is Emacs built-in command.

*** Install
#+begin_src emacs-lisp
  (use-package realgud :defer t)
#+end_src

*** Set local shortkey
Use ~C-c~ as prefix and then press ~n/s/r/u/q~ to ~next/step/restart/older-frame/quit~

#+begin_src emacs-lisp
  (with-eval-after-load 'realgud
    (add-hook 'realgud-short-key-mode-hook
              (lambda ()
                (local-set-key "\C-c" realgud:shortkey-mode-map))))
#+end_src


* Compile and Run

** quickrun

#+begin_src emacs-lisp
  (use-package quickrun
    :defer t
    :bind
    (("C-x P" . quickrun-keymap)
     :map toggle-map
     ("q" . quickrun-autorun-mode))
    :config
    (defvar quickrun-keymap
      (let ((keymap (make-keymap)))
        (define-key keymap "r" #'quickrun)
        (define-key keymap "M-r" #'quickrun-select)
        (define-key keymap "R" #'quickrun-region)
        (define-key keymap "a r" #'quickrun-with-arg)
        (define-key keymap "s r" #'quickrun-shell) ;; default run from eshell
        (define-key keymap "c" #'quickrun-compile-only)
        (define-key keymap "s c" #'quickrun-compile-only-select)))
    (defalias 'quickrun-keymap quickrun-keymap)
    (global-set-key (kbd "C-x P") quickrun-keymap)
    (define-key toggle-map "q" #'quickrun-autorun-mode))
#+end_src
* Completion at point(cap)

** COMMENT Company
#+begin_src emacs-lisp
  (use-package company
    :defer t
    :diminish t
    :hook (server-after-make-frame . global-company-mode)
    :custom
    (company-idle-delay 0)
    (company-tooltip-limit 8)
    (company-tooltip-idle-delay 5)
    (company-tooltip-align-annotations t)
    (company-tooltip-flip-when-above t)
    (company-show-quick-access 'right)
    (company-search-candidates #'company-search-flex-regexp)
    ;; (company-quick-access-keys '("a" "r" "s" "t" "d" "h" "e" "i" "o"))
    (company-require-match nil)
    (company-format-margin-function #'company-text-icons-margin)
    (company-selection-wrap-around t) ;; cycle company selections
    (company-global-modes '(not erc-mode message-mode eshell-mode vterm-mode dashboard-mode))
    (company-backends '(company-capf company-files :separate
                                     (company-keywords company-dabbrev company-dabbrev-code company-etags)))
    (company-files-exclusions '(".git/" ".DS_Store"))
    :bind
    (:map company-active-map
          ("C-y"		. company-complete-selection) ;; orig. return
          ("<tab>"	. company-indent-or-complete-common)
          ("C-w"		. company-show-location)
          ("C-h"		. company-show-doc-buffer)
          ("<return>"	. nil))
    )
#+end_src
*** Company-Box
#+begin_src emacs-lisp
  (use-package company-box
    :ensure nil
    :custom
    (company-box-icons-images
     :hook (company-mode . company-box))
#+end_src
** Corfu
- =Company=: can be an alternative chooice
  +-----+------------------------+
  |Key  |Action                  |
  +-----+------------------------+
  |Tab  |corfu-complete          |
  +-----+------------------------+
  |C-n  |corfu-next              |
  +-----+------------------------+
  |C-p  |corfu-previous          |
  +-----+------------------------+
  |RET  |corfu-insert            |
  +-----+------------------------+
  |C-v  |corfu-scroll-up         |
  +-----+------------------------+
  |M-v  |corfu-scroll-down       |
  +-----+------------------------+
  |M-h  |corfu-info-documentation|
  +-----+------------------------+
  |C-M-i|completion-at-point     |
  +-----+------------------------+

#+begin_src emacs-lisp
  (use-package corfu
    :demand t
    ;; bindings
    ;; tab   corfu-complete
    ;; C-n/p corfu-next/previous
    ;; RET   corfu-insert
    ;; C-v   corfu-scroll-up
    ;; M-v   corfu-scroll-down
    ;; M-h   corfu-info-documentation
    :custom
    (corfu-cycle t)
    (corfu-auto t)
    ;; temporary fix corfu bug in `run-python'
    (corfu-auto-delay 0.1)
    ;; (corfu-separator ?_)
    ;; (corfu-separator ?_) ;; orig. " " space
    (corfu-preview-current nil)
    :bind
    ("M-/"   . #'completion-at-point)
    ("C-M-i" . #'complete-symbol)
    :init
    (global-corfu-mode)
    :config
    ;; remove RET map for =corfu-insert=, so that popup will no longer interrupt typing.
    (define-key corfu-map (kbd "RET") nil)
    (define-key corfu-map [return] nil))
#+end_src

*** corfu-popupinfo
#+begin_src emacs-lisp
  (defvar my/corfu-extensions-load-path
    "lib/corfu/extensions/")

  (use-package corfu-popupinfo
    ;;:straight nil
    ;; :ensure nil
    :load-path my/corfu-extensions-load-path
    :custom
    (corfu-popupinfo-delay '(0.8 . 0.5))
    :hook (corfu-mode . corfu-popupinfo-mode)
    )
#+end_src


** Orderless
#+begin_src emacs-lisp
  (use-package orderless
    :init
    (with-eval-after-load 'consult
      (require 'orderless)
      (defun +orderless--consult-suffix ()
        "Regexp which matches the end of string with Consult tofu support."
        (if (and (boundp 'consult--tofu-char) (boundp 'consult--tofu-range))
            (format "[%c-%c]*$"
                    consult--tofu-char
                    (+ consult--tofu-char consult--tofu-range -1))
          "$"))

      ;; Recognizes the following patterns:
      ;; * .ext (file extension)
      ;; * regexp$ (regexp matching at end)
      (defun +orderless-consult-dispatch (word _index _total)
        (cond
         ;; Ensure that $ works with Consult commands, which add disambiguation suffixes
         ((string-suffix-p "$" word)
          `(orderless-regexp . ,(concat (substring word 0 -1) (+orderless--consult-suffix))))
         ;; File extensions
         ((and (or minibuffer-completing-file-name
                   (derived-mode-p 'eshell-mode))
               (string-match-p "\\`\\.." word))
          `(orderless-regexp . ,(concat "\\." (substring word 1) (+orderless--consult-suffix))))))
      (orderless-define-completion-style +orderless-with-initialism
        (orderless-matching-styles '(orderless-initialism orderless-literal orderless-regexp)))
      (setq completion-styles '(orderless partial-completion basic)
            completion-category-defaults nil
          ;;; Enable partial-completion for files.
          ;;; Either give orderless precedence or partial-completion.
          ;;; Note that completion-category-overrides is not really an override,
          ;;; but rather prepended to the default completion-styles.
            ;; completion-category-overrides '((file (styles orderless partial-completion))) ;; orderless is tried first
            completion-category-overrides '((file (styles . (partial-completion))) ;; partial-completion is tried first
                                            ;; enable initialism by default for symbols
                                            (command (styles +orderless-with-initialism))
                                            (variable (styles +orderless-with-initialism))
                                            (symbol (styles +orderless-with-initialism)))
            orderless-component-separator #'orderless-escapable-split-on-space ;; allow escaping space with backslash!
            orderless-style-dispatchers (list #'+orderless-consult-dispatch
                                              #'orderless-affix-dispatch))))
#+end_src
*** Use Orderless as pattern compiler for consult-ripgrep/find
#+begin_src emacs-lisp
  (with-eval-after-load 'orderless
    (defun consult--orderless-regexp-compiler (input type &rest _config)
      (let
          (( input (orderless-pattern-compiler input)))
        (cons
         (mapcar (lambda (r) (consult--convert-regexp r type)) input)
         (lambda (str) (orderless--highlight input str)))))

    (defun consult--with-orderless (&rest args)
      (minibuffer-with-setup-hook
          (lambda ()
            (setq-local consult--regexp-compiler #'consult--orderless-regexp-compiler))
        (apply args)))
    ;; add
    (defvar-local override-commands '(consult-ripgrep consult-find))
    (dolist (cmd override-commands)
      (advice-add cmd :around #'consult--with-orderless)))
#+end_src
** Cape
Completion At Point Extensions:
- =cape-dabbrev=: word from current buffers (see also =dabbrev-capf= on Emacs 29)
- =cape-file=: file name
- =cape-history=: from Eshell, Comint or minibuffer history
- =cape-keyword=: programming languages keyword
- =cape-symbol=: complete ~elisp~ symbol
- =cape-abbrev=: Complete abbreviation(=add-global-abbrev=, =add-mode-abbrev=)
- =cape-ispell=: Complete word from Ispell dictionay
- =cape-dict=: Complete word from dictionary file
- =cape-line=: Complete entire line from current buffer
- =cape-tex=: Complete Unicode char from TeX command, e.g. =\hbar=
- =cape-sgml=: Complete Unicode char from SGML entity, e.g. =&alpha=.
- =cape-rfc1345=: Complete Unicode char unsing RFC 1345 menemonics

*** Setup Cape Completions
#+begin_src emacs-lisp
  (use-package cape
    :preface
    (defvar global-cape-extensions '(tempel-complete cape-elisp-block
                                                     cape-dabbrev cape-file cape-abbrev))
    (defvar prog-cape-extensions '(cape-keyword cape-file cape-dabbrev cape-abbrev))
    (defun extend-completion-func (func-or-funcs)
      (if (listp func-or-funcs)
          (dolist (func func-or-funcs)
            (add-to-list 'completion-at-point-functions func))
        (add-to-list 'completion-at-point-functions func-or-funcs)))
    :config
    (extend-completion-func global-cape-extensions)
    (add-hook 'prog-mode-hook (lambda () (extend-completion-func prog-cape-extensions))))
#+end_src

* Centaur Tab

#+begin_src emacs-lisp
  (use-package centaur-tabs
    :ensure nil
    :defer t
    :custom
    (centaur-tabs-style "wave")
    (centaur-tabs-set-icons t)   ;; need all-the-icons
    (centaur-tabs-gray-out-icons 'buffer)
    (centaur-tabs-set-bar 'under)
    (centaur-tabs-set-close-button nil)
    (centaur-tabs-set-modified-marker t)
    (centaur-tabs-change-fonts "Menlo" 180)
    :hook
    (dashboard-mode . centaur-tabs-local-mode)
    (calendar-mode . centaur-tabs-local-mode)
    :bind
    ;; (setq centaur-tabs-set-icons nil)
    ;; <next>/<prior> scroll-down/up-command can use the alternative key: C/M-v
    ("<prior>" . centaur-tabs-backward)
    ("<next>" . centaur-tabs-forward)
    ("C-c t c" . centaur-tabs-close-selected)
    ("C-c t C" . centaur-tabs-close-unselected)
    ("C-c t s" . centaur-tabs-switch-group)
    ("C-c t p" . centaur-tabs-group-by-projectile-project) ;; need projectile
    ("C-c t g" . centaur-tabs-group-buffer-groups) ;; use user's group configuration
    :config
    (centaur-tabs-mode t)
    (defvar my--centaur-vc-modes
      '(magit-blame-mode magit-blob-mode magit-diff-mode
                         magit-file-mode magit-log-mode
                         magit-process-mode magit-status-mode))

    (defvar my--centaur-text-modes
      '(org-mode org-agenda-clockreport-mode org-src-mode
                 org-agenda-mode org-agenda-log-mode
                 ;; org-beamer-mode org-indent-mode org-bullets-mode
                 ;; org-cdlatex-mode
                 diary-mode))
    (defun my-centaur-tabs-buffer-groups ()
      (let ((bn (buffer-name)))
        (list
         (cond
          ((memq major-mode '(helpful-mode help-mode))
           "Help")
          ((derived-mode-p 'prog-mode)
           "Programming")
          ((derived-mode-p 'dired-mode)
           "Dired")
          ((memq major-mode my--centaur-vc-modes)
           "Magit")
          ;; Shell
          ;; ((memq major-mode
          ((memq major-mode '(eshell-mode shell-mode vterm-mode))
           "Shell")
          ;; Text modes: like org-mode
          ((or (string-prefix-p "*Org Src" bn)
               (string-prefix-p "*Org Export" bn)
               (memq major-mode my--centaur-text-modes))
           "Text")
          ((string-prefix-p "*" bn)
           "Emacs")
          (t
           (centaur-tabs-get-group-name (current-buffer)))))))
    (advice-add 'centaur-tabs-buffer-groups :override 'my-centaur-tabs-buffer-groups)
    ;; (setq centaur-tabs-buffer-groups 'my-centaur-tabs-buffer-groups)
    )
#+end_src

* COMMENT TS Fold
not support Emacs29+ (treesit)
#+begin_src emacs-lisp
  (use-package ts-fold
    :ensure nil
    :defer t
    :hook (prog-mode . ts-fold-mode)
    ;; :bind
    :bind
    ("C-`" . ts-fold-toggle)
    ("C-~" . ts-fold-close-all)
    ("C-M-`" . ts-fold-open-recursively))
#+end_src


* End

#+begin_src emacs-lisp
  (provide 'programming)
#+end_src
